{
  "hash": "052a592afdc9ff954d1c3f809baf2ea8",
  "result": {
    "markdown": "---\ntitle: Benchmarking Data Tables\nauthor: Mark Edney\ndate: '2022-04-13'\nslug: []\ncategories:\n  - How-to\n  - R\ndraft: false\ndescription: 'A look into the claim performance of Data Tables in the R language.'\nimage: \"racecar.jpg\"\narchives:\n  - 2022/04\n---\n\n\n![](racecar.jpg)\n\nWhen I started learning R, I heard vague tales of the use of Data Tables. Really just whisperers, of something to consider in the future after I've become more proficient. Well now is the time to learn what if anything I've been missing out on.\n\n## Introduction\n\nData Tables are a potential replacement for the common dataframe. It  seeks to perform that same role but with improved performance. I would like to see the speed comparison between Data Frames, Data Tables and Tibbles. I will use the `microbenchmark` package to perform the actual benchmarking.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(data.table)\nlibrary(microbenchmark)\nlibrary(farff)\n```\n:::\n\n\nFor the benchmark, I will use the 'credit-g' dataset, which can be found on the [open ml](https://www.openml.org/search?type=data&status=active&id=31) website. I'm pretty sure the last open ml dataset I used was a csv file, but they seem to have moved to a ARFF format. I will need to use the `farff` package to load the data. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- farff::readARFF('dataset_31_credit-g.arff')\ndt <- setDT(df)\nti <- tibble(df)\n```\n:::\n\n\n## Syntax\n\nThe syntax for Data Tables is a little different:\n\n> DT[i,j,by]\n\nIn this manner, a data table can be subset by i, to calculate j when grouped with a by. Along with the special syntax, there are some common functions that add some additional simplification.\n\n> .()\n\nThe '.()' function can be used as a placeholder for 'list()'. The list function is useful for subsetting.\n\n## Grouped Aggregate\n\nAggregating data in Data Tables is simple by using the j and by parameters in the syntax. Again, multiple functions or even multiple groupings can be passed with the '.()' function. For this comparison, we will look at the performance of finding the average age of the credit holders grouped by the class or credit rating. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup <- microbenchmark(Data_Frame = df %>% \n                                 group_by(class) %>%\n                       summarise(avg = mean(age)),\n               Data_Table = dt[,.(avg = mean(age)), by = class],\n               Tibble = ti %>% \n                       group_by(class) %>%\n                       summarise(avg = mean(age)))\nprint(group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: microseconds\n       expr    min     lq     mean  median      uq     max neval\n Data_Frame 5406.5 5564.6 6138.870 5904.40 6306.95 17135.6   100\n Data_Table  623.6  766.8  941.930  885.95  958.05  7471.7   100\n     Tibble 5602.8 5783.1 6586.445 6103.15 6902.65 14356.9   100\n```\n:::\n:::\n\n\n\n\n## Taking counts\n\nAnother function of interest is the '.N' function. This function will return the count of rows. The test looks are the number of people with over 5000 in credit and younger than 35. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts <- microbenchmark(Data_Frame = df %>% \n                                 filter(credit_amount > 5000, age <35) %>%\n                       nrow(),\n               Data_Table = dt[credit_amount > 5000 & age < 35, .N ,],\n               Tibble = ti %>% \n                       filter(credit_amount > 5000, age <35) %>%\n                       nrow())\nprint(counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: microseconds\n       expr    min      lq      mean  median      uq     max neval\n Data_Frame 8404.1 8584.90  9576.638 8927.45 9867.95 17254.5   100\n Data_Table  276.7  309.50   429.832  451.80  466.35  1045.6   100\n     Tibble 8945.1 9204.75 10206.312 9405.45 9942.45 27081.9   100\n```\n:::\n:::\n\n\n\n## Creating new columns\n\nData Tables also contain a very simple syntax for creating a new column with ':='. I compare this to the `tidyverse` mutate function. Using the base R to create a column is still the fastest  method, taking about half the time of the Data Table method. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew <- microbenchmark(Data_Frame = df %>% mutate(property = paste(property_magnitude, housing)),\n               Data_Table = dt[,property := paste(property_magnitude, housing)],\n               Tibble = ti %>% mutate(property = paste(property_magnitude, housing)))\nprint(new)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: microseconds\n       expr    min      lq     mean median      uq    max neval\n Data_Frame 2071.3 2148.55 2396.203 2259.6 2586.40 3386.1   100\n Data_Table  505.7  580.00  657.802  656.6  694.35  996.0   100\n     Tibble 2585.3 2754.85 3187.554 2922.9 3331.70 8879.8   100\n```\n:::\n:::\n\n\n\n\n## Chaining Data Tables\n\nAnother point of exploration is that Data Tables can be chained together to create more complicated structures\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[credit_amount > 1000, .(age = mean(age)),by = .(purpose, class)][class == \"good\" & age < mean(age)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               purpose class      age\n1:            radio/tv  good 35.44865\n2: furniture/equipment  good 33.21930\n3:            used car  good 36.91860\n4:            business  good 34.50000\n5:  domestic appliance  good 35.50000\n6:          retraining  good 34.00000\n```\n:::\n:::\n\nI don't think this is the most useful feature, as you can already create some very complicated transformation with a single call. Chaining also makes it more difficult to understand. \n\n## Conclusions\n\n\n\n\nIt is clear that there are significant performance improvements when using Data Tables versus Data Frames\n(an average decrease of time by -85%). There are also insignificant differences between Data Frames and Tibbles. Also, the syntax for Data Tables is fairly simple and straight forward and yet extremely powerful.\n\nSo, to answer the most important question, should you change to Data Tables from Data Frames? Probably, they present a significant performance gain and their structure is very flexible. \n\n> Photo by [Tyler Clemmensen](https://unsplash.com/@tyler_clemmensen?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/race-car?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n  ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}