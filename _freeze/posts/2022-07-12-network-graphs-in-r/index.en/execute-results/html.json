{
  "hash": "42f665da8e388ec6f18613aa9010949e",
  "result": {
    "markdown": "---\ntitle: \"Network Graphs in R\"\nauthor: \"Mark Edney\"\ndate: '2022-07-12'\nslug: []\ncategories:\n- How-to\n- Project\n- NLP\n- R\n- GGPlot\ndraft: false\ndescription: 'A look at the diffrent options for exploring network graphs in R.'\nimage: 'storm_graph.png'\ntoc: true\narchives: 2022/07\n---\n\n![](storm_graph.png)\n\n## Introduction\nNetwork graphs are an important tool for network analysis. They illustrate points, referred to as nodes, with connecting lines, referred to as edges. Since network graphs are such useful tools, there are many options for graph generation. In this posting, I will demonstrate three different techniques for developing network graphs in `r`. \n\nThis is part 3 of a series which is based on the **Stormlight Archive** by Brandon Sanderson. This project was originally inspired by the work of [Thu Vu](https://www.youtube.com/watch?v=RuNolAh_4bU) where she created a network mapping of the characters in the Witcher series.\n\nIn the first part of the project, we scrapped the Coopermind website to create a verified character name list. This scrapping was performed with the `rvest` package. The list was then cleaned up and saved for further use. \n\nFor the second part of the project, we read through and analyzed the four books that make up the **Stormlight Archive** series. The books were read into memory with the `readtext` package, which fed nicely into the `quanteda` to create the body of text called a Corpus. Unfortunately, the body of text was so big that we were unable to model all the text, so we divided the Corpus up into smaller documents with the `rainette` package.\n\nWith the corpus finally prepped, we feed it into the `spacyr` package, a frontend for the `spaCy` `python` library, to identify the entities. We were able to create a table identifying the entities that were people and filter it by the verified character list. We created a moving window model that would create a connection between two named characters if they were both mentioned within the same window. By aggregating the results of this model, we developed the foundation for a network graph.\n\n## Initialization\nThe first step of this process is to load in the necessary packages for the graph generation. The `Tidyverse` package is always useful for analysis, so I've loaded it too. I have read that the different graph packages can interrupt each other, requiring one of them to be loaded at a time. I have not found this to be an issue. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(ggraph)\nlibrary(networkD3)\n```\n:::\n\n\nThe next step is to load in the data that we created in part two of the project. This data represents that relationship between all the verified characters as read through the series of books. Saving and loading data in RDS format is much more convenient than the CSV format, as RDS files are compressed and seem to load faster.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_rds(\"StormGraph.RDS\")\n```\n:::\n\n\n## IGraph\nThe first package to explore is the `igraph` package. This package is not only for plotting graphs, but also includes many tools for network analysis. For our data, we can create a simple network graph with the `graph_from_data_frame` function. The relationships are not directional, so we pass this information to the function. The graph can then be plotted with the `plot` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph <- graph_from_data_frame(data, directed = FALSE)\nplot(graph)\n```\n\n::: {.cell-output-display}\n![](index.en_files/figure-html/graph-1.png){width=672}\n:::\n:::\n\n\nThe graph created is a mess. There are way too many character nodes and way too many relationships created. We need to create a smaller dataset to reduce the amount of information. I reduced the size of the data by taking only the top 98% quantile in relationships. Since the data is stored as a data table, the data table notation is used to create a subset.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2 <- data[data$N >= quantile(data$N, p = 0.98),,]\ndata2 %>%\n        graph_from_data_frame(directed = FALSE) %>%\n        plot(layout = layout_with_graphopt)\n```\n\n::: {.cell-output-display}\n![](index.en_files/figure-html/smaller-1.png){width=672}\n:::\n:::\n\n\nThe plot created is still difficult to understand, but it much more reasonable. I feel the `igraph` package is best for graph analysis and exploratory plots. For a more attractive plot, we need to move on to the next package. \n\n## Tidygraph and GGraph\nThe `tidygraph` and `ggraph` packages seek to create graphs in the tidyverse-like environment. \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidygraph)\n```\n:::\n\nCreating a graph with `ggraph` requires more structure than the previous `igraph`. The graph requires two data frames, one for nodes and one for edges.\n\nFor the nodes dataframe, we need a list of all the node names and an ID number for each node. This is achieved by finding the unique values within both columns of data. These values are then passed to the tibble function to create a tibble, a data structure similar to data frames, and then a column for IDs is created with the `rowid_to_column` function. \n\n::: {.cell}\n\n```{.r .cell-code}\nnodes <- c(data2$Person1, data2$Person2) %>% \n        unique() %>%\n        tibble(label = .) %>%\n        rowid_to_column(\"id\")\n```\n:::\n\n\nFor the edges dataframe, we need some additional steps. As a reminder, in our subset of data, we have rows with two names and a number to represent the strength of their bond. The character names need to in the form of the node IDs rather than the names. This task is completed with two merges with the node dataframe. The graph can then be created with the `tbl_graph` function.   \n\n::: {.cell}\n\n```{.r .cell-code}\nedges <- data2 %>%\n        left_join(nodes, by = c(\"Person1\"=\"label\")) %>%\n        rename(from = \"id\") %>%\n        left_join(nodes, by = c(\"Person2\"=\"label\")) %>%\n        rename(\"to\" = \"id\") %>%\n        select(from, to, N)\n\ngraph_tidy <- tbl_graph(nodes = nodes, edges = edges, directed = FALSE)\n```\n:::\n\n\nFor the plotting of the graph, we use the `ggraph` library. With this package, the graph can act as any other `ggplot` geom. With an extra step, we can create a centrality feature in our graph. There are a bunch of different centrality measures, but they all represent the level of importance of a node. \n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_tidy %>%\n        mutate(Centrality = centrality_authority()) %>%\n        ggraph(layout = \"graphopt\") + \n        geom_node_point(aes(size=Centrality, colour = label), show.legend = FALSE) +\n        geom_edge_link(aes(width = N), alpha = 0.8, show.legend = FALSE) + \n        scale_edge_width(range = c(0.2, 2)) +\n        geom_node_text(aes(label = label), repel = TRUE)\n```\n\n::: {.cell-output-display}\n![](index.en_files/figure-html/ggraph-1.png){width=672}\n:::\n:::\n\n\n## Network D3\n\nThe `ggraph` has created a better looking plot with a much higher level of customization. It is however a static plot with no level of interaction. I have tried using the `ggplotly` function from the `plotly` package it make it more interactive, but many of the `ggraph` features are not supported. \n\nTo create an interactive plot, we move to the `networkD3` package. This package is based on the `D3` JavaScript library to create interactive plots. We can use the same nodes and edges data frames from the `ggraph` plot. This process does require one adjustment to the node IDs, as the package requires an initial ID of 0 rather than the default `r` index of 1. \n\nThe function from the `tidygraph`, `centrality_authority`, is only supported for the tidygraph data structure, so we need an alternative function to use with our data frame. This is achieved with the `authority.score` function from the `igraph` package. Besides that, we normalize the edge width values, node sizes and set all the parameters for the `forceNetwork` function.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges <- edges %>%\n        mutate(from = from -1, to = to - 1) %>%\n        mutate(N = N / 200)\n\nnodes <- nodes %>%\n        mutate(id=id-1) %>%\n        mutate(nodesize = authority.score(graph_tidy)$vector*150)\n        \nforceNetwork(Links = edges, Nodes = nodes, Source = \"from\", Target = \"to\", NodeID = \"label\", Group = \"id\", opacity = 1, fontSize = 14, zoom = TRUE, Value = \"N\", Nodesize = \"nodesize\", opacityNoHover = TRUE)\n```\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"htmlwidget-f8e5b18f4fc804fdf1fa\" style=\"width:100%;height:464px;\" class=\"forceNetwork html-widget\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-f8e5b18f4fc804fdf1fa\">{\"x\":{\"links\":{\"source\":[0,0,1,2,2,2,2,3,4,5,0,6,7,0,6,8,8,9,9,0,7,7,2,1,1,7,7,7,2,5,0,10,2,2,2,2,2,2,2,10,10,10,11,11,0,6,12,13,2,2,14,11,11,11,15,15,16,16,17,17,7,14,14,14,14,14,14,14,7,18,6,19,19,6,19,19],\"target\":[7,4,2,1,0,20,3,2,0,0,21,7,6,1,0,0,2,0,2,6,0,21,22,7,0,2,3,23,5,2,2,2,4,21,6,7,13,23,24,0,6,7,2,0,3,2,2,2,25,19,2,7,6,4,0,2,0,2,0,2,24,7,0,23,6,24,3,19,19,2,24,24,6,19,2,0],\"value\":[5.3,1.52,4.85,2.17,21.445,1.125,4.815,2.07,1.29,1.32,1.655,1.46,8.625,1.565,3.965,1.875,2.68,1.9,2.7,5.82,7.61,1.265,1.76,1.16,1.785,17.735,1.995,2.095,1.14,3.21,10.73,9.385,3.265,3.075,12.135,6.685,1.295,3.815,3.44,4.14,1.375,2.56,9.755,8.8,1.465,5.44,3.565,3.665,1.245,2.95,11.565,1.85,3.34,1.425,3.275,4.195,3.275,4.195,1.72,1.745,3.18,1.915,4.47,1.39,6.91,2.83,1.26,2.935,3.305,2.265,2.665,2.09,4.82,4.875,3.57,1.375],\"colour\":[\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\",\"#666\"]},\"nodes\":{\"name\":[\"Dalinar\",\"Stormfather\",\"Kaladin\",\"Teft\",\"Elhokar\",\"Adolin\",\"Navani\",\"Jasnah\",\"Vandonas\",\"Rayse\",\"Derethil\",\"Maps\",\"Vathah\",\"Shallan\",\"Glys\",\"Vazrmeb\",\"Droz\",\"Mem\",\"Lyon\",\"Raboniel\",\"Lirin\",\"Renarin\",\"Lopen\",\"Szeth\",\"Venli\",\"Rlain\"],\"group\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25],\"nodesize\":[125.446907297931,59.2854876372364,150,53.554728406178,40.314163546729,38.2802977631194,100.341945628879,108.00459625225,24.7837966346087,24.7837966346087,43.5301255520752,47.1574599107645,13.4965011285107,26.9930022570214,61.7552974152141,24.7837966346087,24.7837966346087,24.7837966346087,13.4965011285107,75.6249030064492,13.4965011285107,34.5016910026276,13.4965011285107,28.7709317715693,44.6038435794839,13.4965011285107]},\"options\":{\"NodeID\":\"label\",\"Group\":\"id\",\"colourScale\":\"d3.scaleOrdinal(d3.schemeCategory20);\",\"fontSize\":14,\"fontFamily\":\"serif\",\"clickTextSize\":35,\"linkDistance\":50,\"linkWidth\":\"function(d) { return Math.sqrt(d.value); }\",\"charge\":-30,\"opacity\":1,\"zoom\":true,\"legend\":false,\"arrows\":false,\"nodesize\":true,\"radiusCalculation\":\" Math.sqrt(d.nodesize)+6\",\"bounded\":false,\"opacityNoHover\":true,\"clickAction\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::",
    "supporting": [
      "index.en_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.5.4/htmlwidgets.js\"></script>\r\n<script src=\"../../site_libs/d3-4.5.0/d3.min.js\"></script>\r\n<script src=\"../../site_libs/forceNetwork-binding-0.4/forceNetwork.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}