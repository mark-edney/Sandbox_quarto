{
  "hash": "318b02e7fcc80bf8ad79c4463af12c2b",
  "result": {
    "markdown": "---\ntitle: New features in R\nauthor: Mark Edney\ndate: '2022-02-23'\nslug: []\ncategories:\n  - General\n  - R\ndraft: false\ndescription: 'A look at the new features introduced in the 4.0 version of R'\narchives:\n  - 2022/02\nimage: \"new.jpg\"\n---\n\n![](new.jpg)\n> Photo by [Clint Patterson](https://unsplash.com/@cbpsc1?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/update?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n\nRecently I had updated my RStudio client and with it came a new update to R. This is an exploration of some of the most interesting changes from R 4.0 to R 4.1.\n\n## Native Pipe Function\n\nDue to the extreme popularity of the magrittr pipe ('%\\>%'), R has developed its own native pipe ('\\|\\>').\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ndata(\"morley\")\nmorley |>\n        group_by(Expt) |>\n        summarise(mean = mean(Speed, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 Ã— 2\n   Expt  mean\n  <int> <dbl>\n1     1  909 \n2     2  856 \n3     3  845 \n4     4  820.\n5     5  832.\n```\n:::\n:::\n\n\nFrom this example, it is apparent that the behaviour of the native pipe is the same as the magrittr pipe.\n\nSome of the differences I have found is that the native pipe requires the brackets for functions, while the magrittr pipe will usually accept just the function name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 %>% sqrt()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214\n```\n:::\n\n```{.r .cell-code}\n2 |> sqrt()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214\n```\n:::\n\n```{.r .cell-code}\n2 %>% sqrt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n2 |> sqrt\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: The pipe operator requires a function call as RHS\n```\n:::\n:::\n\n\nOne disadvantage of the native pipe is that it doesn't support the placeholder operator (.) which helps refer to the data in the function. This is a useful function of the magrittr pipe when the data isn't the first argument in the function, such as the lm function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmorley %>% lm(Speed~Run, data = .)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = Speed ~ Run, data = .)\n\nCoefficients:\n(Intercept)          Run  \n   856.0947      -0.3519  \n```\n:::\n\n```{.r .cell-code}\nmorley |> lm(Speed~Run, data = .)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in is.data.frame(data): object '.' not found\n```\n:::\n:::\n\n\nOne advantage is there is no performance penalty as it acts the same as the function call. This is shown with the microbenchmark function, which shows not only the same level of performance as the regular call, but even the results themselves are shown as the function call.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\nmicrobenchmark(sqrt(3),\n               4 |> sqrt(),\n               5 %>% sqrt())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: nanoseconds\n         expr  min   lq mean median   uq   max neval\n      sqrt(3)  100  100  239    200  200  5700   100\n      sqrt(4)    0  100  215    100  200  6800   100\n 5 %>% sqrt() 3200 3500 5110   3700 4000 43300   100\n```\n:::\n:::\n\n\nSo when should we use the native vs the magrittr pipe? Well, it looks like not all the functionality of the magrittr pipe is carried over, so it should still be continued to be used. The native pipe, however, provides a good performance boost, which makes it a better option for code written in functions and libraries. I think that the major application should be to increase the readability of library and function code.\n\n## Lambda Functions\n\nThere has been a simplification in the creation of lambda functions. The notation is simplified, while the results are the same.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nx <- 0:10/10\ny1 <- function(x) x + 0.5\ny2 <- \\(x) x^2 +1\ng <- ggplot(data.frame(x=x)) +\n        geom_function(fun = y1, aes(color = \"blue\")) +\n        geom_function(fun = y2, aes(color = \"red\"))\ng\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/lambda-1.png){width=672}\n:::\n:::\n\n\n## Other minor changes\n\n-   The default has been changed for 'stringsAsFactors = FALSE'. Previously, when using the data.frame() or the read.table() the default option would turn strings into factors. This was an annoying feature that would always create headaches.\n-   Introduction of an experimental implementation of hash tables. This development should be watched for people keen on program performance.\n-   c() can now combine factors to create a new factor. I am not familiar with the original behaviour, but this seems intuitive.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}