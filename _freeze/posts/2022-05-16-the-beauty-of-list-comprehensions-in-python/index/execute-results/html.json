{
  "hash": "30117d96bdd1387de8241ebbef6ade58",
  "result": {
    "markdown": "---\ntitle: The beauty of List comprehensions in Python\nauthor: Mark Edney\ndate: '2022-05-16'\nslug: []\ncategories:\n  - How-to\n  - Python\ndraft: false\nimage: 'beauty-list.jpg'\ndescription: 'List Comprehensions are an elegent and useful tool in Python, that every Python coder should know about.'\narchives:\n  - 2022/05\n---\n\n![](beauty-list.jpg)\n\nI have spent awhile learning Python, and I was a little perplexed when it came to list comprehensions. Why would you use them? Isn't there just an easier why?\n\nAs my proficiency increase, I have found them to be an incredibly useful tool. They save you lines of code, are easy to understand, and are usually better for performance. A good list comprehension, is truly a work of beauty.\n\n## Structure\n\nThe basic structure of a list comprehension is pretty simple, you contain an expression and an iterable within a set of `[]`. Depending on the type of brackets used, you can create a list, a generator, set or a dictionary.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n[i for i in range(5)]\n(i for i in range(5))\n{i for i in range(5)}\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n{0, 1, 2, 3, 4}\n```\n:::\n:::\n\n\nIt may appear from first impressions that a list comprehension is a simple one line for loop, but it is much more powerful than that. \n\n### Conditions\n\nMuch more complicated lists can be created with an included if statement. The if statement fits right at the end of the statement. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n[a for a in range(10) if a % 2 == 0]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n[0, 2, 4, 6, 8]\n```\n:::\n:::\n\n\nBut what if you need to create an even more complicated list, one that requires an else statement along with the if statement. Then the structure of the list comprehension changes a little, the iterable statement is moved to the end. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n[a if a % 2 == 0 else 0 for a in range(10)]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[0, 0, 2, 0, 4, 0, 6, 0, 8, 0]\n```\n:::\n:::\n\n\n### Expressions\n\nOf course, expressions can be more complicated than returning single values. One common issue I find is when I have a list of a value type and I need them to be of a different type. This conversion is easy with list comprehensions. \n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\na = ['0', '1', '2', '3', '4']\n[int(x) for x in a]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n[0, 1, 2, 3, 4]\n```\n:::\n:::\n\n\nThere is nearly an unlimited potential of different expressions you can use.\n\n### More Iterables\n\nList comprehensions are not limited to a single iterable. Far warning, however, increasing the number of iterables will reduce readability. At some level of complication, it will be a better idea to separate steps. \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\na = range(5)\nb = [5,10,15]\n[x*y for x in a for y in b]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n[0, 0, 0, 5, 10, 15, 10, 20, 30, 15, 30, 45, 20, 40, 60]\n```\n:::\n:::\n\n\nThe results are an element-wise evaluation across multiple iterables. These iterables don't need to be the same size.\n\n### Dictionary Comprehensions\n\nAs previously mentioned, by changing the structure, we can generate dictionaries.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n{char : num for num, char in enumerate(['a','b','c','d','e'])}\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n{'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4}\n```\n:::\n:::\n\n\nLikewise, you can create a set rather than a list. Sets can be useful if you don't need the data to be in order, and you don't want any duplicate values. \n\n### Other Applications\n\nThere is great potential in list comprehensions. Often I find that I need to create a list of zeroes or of boolean logic of the same size as a current list. This is easy to create, just don't refer to the iterable within the expression. \n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\na = range(5)\n[True for x in a]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n[True, True, True, True, True]\n```\n:::\n:::\n\n\nWhile it may not be best practice, you can nest a list comprehension within another list comprehension. \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n[x for x in [b for b in range(20) if b %2 == 0] if x %3 == 0]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n[0, 6, 12, 18]\n```\n:::\n:::\n\n\n### Conclusions\n\nHopefully I have won you over with the beauty of list comprehensions. They are simple and clean to create yet extremely flexible in their design. So take a minute, to really appreciate the beauty of list comprehensions. \n\n>Photo by [Kelly Sikkema](https://unsplash.com/@kellysikkema?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/lists?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}